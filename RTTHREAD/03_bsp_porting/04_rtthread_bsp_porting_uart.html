<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12. rt-thread 移植BSP驱动 uart篇 &mdash; bluetoothlover_wiki 0.0.1 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="13. 如何用docker来学习rtthread-qemu" href="../04_docker/01_docker_images.html" />
    <link rel="prev" title="11. RTTHREAD移植BSP驱动 SPI篇" href="03_rtthread_bsp_porting_spi.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> bluetoothlover_wiki
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">BLE knowledge:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../ble/index.html">BLE STACK篇</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ble_profile/index.html">BLE PROFILE篇</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nordic/index.html">Nordic 篇</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../WB55/index.html">STM32WB55 篇</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../WIKI_FAQ/index.html">WIKI FAQ 篇</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">RTTHRED: RT-Thread</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../01_introduce/01_intruduce.html">1. RTTHREAD贡献TODO目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01_introduce/02_RTTHREAD_introduce.html">2. RT-THREAD —-国产开源之光</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/01_software_package.html">3. RTTHREAD软件包目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/02_software_introduce.html">4. RTTHREAD软件包目录自分类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/03_sensor_list.html">5. RT-Thread 传感器软件包归类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/04_rtthread_auto_update.html">6. RTTHREAD 软件包目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/05_rtthread_bsp_board.html">7. RTTHREAD BSP board支持目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_softpackage_list/06_rtthread_softpackage_build_guide.html">8. 软件包制作小计</a></li>
<li class="toctree-l2"><a class="reference internal" href="01_rtthread_bsp_porting.html">9. RTTHREAD移植新的BSP开发板</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_rtthread_bsp_porting_gpio.html">10. RTTHREAD移植BSP驱动 GPIO篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_rtthread_bsp_porting_spi.html">11. RTTHREAD移植BSP驱动 SPI篇</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">12. rt-thread 移植BSP驱动 uart篇</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">12.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">12.2. 移植</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">准备模板文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">添加函数体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">12.3. 问题&amp;总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../04_docker/01_docker_images.html">13. 如何用docker来学习rtthread-qemu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05_llsync/01_llsync_Environment.html">14. LLSYNC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05_llsync/02_llsync_struct_code.html">15. LLSYNC 移植指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06_simular/01_keil_simulator.html">16. 如何在keil中STM32L496 跑simulator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07_onchip/01_on_chip_file.html">17. STM32如何将文件放到内部flash里面</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../12_ESP32/index.html">ESP32</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DEBUG/index.html">EMBEDDED DEBUG 篇</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../00_supperthomas/index.html">MASTER:supperthomas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../01_helloworldzlg/index.html">WB55:helloworldzlg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../02_Jackistang/index.html">WB55:Jackistang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../03_xupenghu/index.html">WB55:xupenghu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../04_dozingfiretruck/index.html">WB55:dozingfiretruck</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../05_luhuadong/index.html">WB55:luhuadong</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../09_answerinthewind/index.html">WB55:answerinthewind</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../06_chenyingchun0312/index.html">NORDIC:chenyingchun0312</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../07_ylz0923/index.html">NORDIC:ylz0923</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../08_guohp1128/index.html">NORDIC:guohp1128</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../10_jiy/index.html">NORDIC:jiy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../11_ForestRain/index.html">NORDIC:ForestRain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../13_xiangxistu/index.html">NORDIC:xiangxistu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../14_bobwenstudy/index.html">NORDIC:bobwenstudy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../16_ColeStudy/index.html">NORDIC:ColeStudy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">bluetoothlover_wiki</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">RTTHRED: RT-Thread</a></li>
      <li class="breadcrumb-item active"><span class="section-number">12. </span>rt-thread 移植BSP驱动 uart篇</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/RTTHREAD/03_bsp_porting/04_rtthread_bsp_porting_uart.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rt-thread-bsp-uart">
<h1><span class="section-number">12. </span>rt-thread 移植BSP驱动 uart篇<a class="headerlink" href="#rt-thread-bsp-uart" title="此标题的永久链接"></a></h1>
<section id="id1">
<h2><span class="section-number">12.1. </span>简介<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h2>
<p>uart驱动作为常用外设之一，对rt-thread的msh组件使用和一些外接uart模块来说必不可少，这篇文章将介绍如何基于rt-thread的serial框架来编写drv_uart.c和drv_uart.h文件，直到最后一步步实现msh组件的使用。</p>
<p>阅读本篇文章前，确定你已经熟悉了<a class="reference external" href="https://docs.rt-thread.org/#/rt-thread-version/rt-thread-standard/README">rt-thread的使用</a>以及在一个stm32或者其他移植过BSP的开发板上跑起来了rt-thread，并且你已经熟悉了<a class="reference external" href="https://www.rt-thread.org/document/site/programming-manual/device/uart/uart/">UART</a>设备驱动框架的使用方法。</p>
<p>uart作为一种常用的外设，一般情况下只使用两根线 ： tx rx ；在使用时主设备的tx接从设备的rx， 主设备的rx接从设备的tx。 一般情况下作为异步方式使用，即tx和rx互不相干，如果想做半双工通讯，可以只接tx或者rx。当然uart还有许多扩展的通讯方式，比如硬件流控和时钟同步等等，但是一般情况下都不用，这里不做讨论。</p>
</section>
<section id="id2">
<h2><span class="section-number">12.2. </span>移植<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<section id="id3">
<h3>准备模板文件<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>首先准备一个模板文件，drv_uart.c和drv_uart.h。这两个文件里面只有函数体，并没有函数实现，将这两个文件加入到工程中，一般情况下都是可以编译通过的。</p>
<p>drv_uart.c</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2020, Huada Semiconductor Co., Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Change Logs:</span>
<span class="cm"> * Date           Author       Notes</span>
<span class="cm"> * 2020-05-18     xph          first version</span>
<span class="cm"> */</span><span class="w"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Include files</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rtdevice.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rthw.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;drv_usart.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;board_config.h&quot;</span><span class="cp"></span>

<span class="cp">#ifdef RT_USING_SERIAL</span>

<span class="cp">#if !defined(BSP_USING_UART1) &amp;&amp; !defined(BSP_USING_UART2) &amp;&amp; !defined(BSP_USING_UART3) &amp;&amp; \</span>
<span class="cp">    !defined(BSP_USING_UART4) &amp;&amp; !defined(BSP_USING_UART5) &amp;&amp; !defined(BSP_USING_UART6) &amp;&amp; \</span>
<span class="cp">    !defined(BSP_USING_UART7) &amp;&amp; !defined(BSP_USING_UART8) &amp;&amp; !defined(BSP_USING_UART9) &amp;&amp; \</span>
<span class="cp">    !defined(BSP_USING_UART10)</span>
<span class="cp">#error &quot;Please define at least one BSP_USING_UARTx&quot;</span>
<span class="cm">/* UART instance can be selected at menuconfig -&gt; Hardware Drivers Config -&gt; On-chip Peripheral Drivers -&gt; Enable UART */</span><span class="w"></span>
<span class="cp">#endif</span>



<span class="k">static</span><span class="w"> </span><span class="n">rt_err_t</span><span class="w"> </span><span class="nf">hc32_configure</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">struct</span><span class="w"> </span><span class="nc">serial_configure</span><span class="w"> </span><span class="o">*</span><span class="n">cfg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>


<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="n">rt_err_t</span><span class="w"> </span><span class="nf">hc32_control</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hc32_putc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>


<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hc32_getc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ch</span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>



<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_uart_ops</span><span class="w"> </span><span class="n">hc32_uart_ops</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">configure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_configure</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_control</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">putc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_putc</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">getc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_getc</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">dma_transmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">hc32_hw_uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">rt_err_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">INIT_BOARD_EXPORT</span><span class="p">(</span><span class="n">hc32_hw_uart_init</span><span class="p">);</span><span class="w"></span>

<span class="cp">#endif </span><span class="cm">/* RT_USING_SERIAL */</span><span class="cp"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * EOF (not truncated)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>
</pre></div>
</div>
<p>drv_uart.h</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2020, Huada Semiconductor Co., Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Change Logs:</span>
<span class="cm"> * Date           Author       Notes</span>
<span class="cm"> * 2020-05-18     xph          first version</span>
<span class="cm"> */</span><span class="w"></span>
<span class="w"> </span>

<span class="cp">#ifndef __DRV_USART_H__</span>
<span class="cp">#define __DRV_USART_H__</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Include files</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rtthread.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;rtdevice.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;uart.h&quot;</span><span class="cp"></span>


<span class="cm">/* C binding of definitions if building with C++ compiler */</span><span class="w"></span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Global type definitions (&#39;typedef&#39;)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Global pre-processor symbols/macros (&#39;#define&#39;)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Global variable definitions (&#39;extern&#39;)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * Global function prototypes (definition in C source)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">rt_hw_uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __DRV_USART_H__ */</span><span class="cp"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> * EOF (not truncated)</span>
<span class="cm"> ******************************************************************************/</span><span class="w"></span>
</pre></div>
</div>
<p>将这两个文件加入到你的工程中，然后保证编译通过，如果编译出错，把能删除的都删除，只保留函数就行了。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;.\output</span><span class="se">\r</span><span class="s">elease</span><span class="se">\r</span><span class="s">t-thread.axf&quot;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">Warning</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id4">
<h3>添加函数体<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>然后重头戏来了，我们要分别实现每个函数的函数体。这些函数体的实现和你目标MCU的uart驱动有关系，大致思想就是将目标MCU的uart驱动给移植过来。这里我分析一下我的移植思路。</p>
<p>根据rt-thread的设计思想，我们一般情况下分析驱动文件是从drv_xxx.c的最后一行开始分析。这里就是</p>
<p><code class="docutils literal notranslate"><span class="pre">INIT_BOARD_EXPORT(hc32_hw_uart_init);</span></code></p>
<p>然后，找到这个函数，这个函数就是将uart设备注册到serial驱动框架中的，主要是就是将设备的driver层和device层联系起来，当上层调用rt_device_find的时候，就会跟着执行drv_xxx.c里面的硬件配置函数，函数实现看下面代码注释。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">hc32_hw_uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">rt_err_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 当前一共用了多少个串口设备， 在rtconfig.h中的 BSP_USING_UARTx 宏来决定用了多少个串口*/</span><span class="w"></span>
<span class="w">    </span><span class="n">rt_size_t</span><span class="w"> </span><span class="n">obj_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uart_obj</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="p">);</span><span class="w"> </span>
<span class="w">	</span><span class="cm">/* 串口默认配置参数  主要是配置波特率 数据位 停止位 奇偶校验位等等 */</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">serial_configure</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT_SERIAL_CONFIG_DEFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="cm">/* 将这些配置参数放在uart 管理结果体里，同时像device层注册uart设备 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">obj_num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">uart_obj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uart_config</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">uart_obj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">serial</span><span class="p">.</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hc32_uart_ops</span><span class="p">;</span><span class="w"> </span><span class="c1">// 上层操作函数最终会进入到drv层来操作具体的硬件 所以实现drv的ops就是移植的重点</span>
<span class="w">        </span><span class="n">uart_obj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">serial</span><span class="p">.</span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">config</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* register UART device */</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_hw_serial_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_obj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="n">uart_obj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">RT_DEVICE_FLAG_RDWR</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RT_DEVICE_FLAG_INT_RX</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">RT_DEVICE_FLAG_INT_TX</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后就要实现各个ops函数了，这个是我们移植的重点和难点。ops操作函数的每个意义如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_uart_ops</span><span class="w"> </span><span class="n">hc32_uart_ops</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">configure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_configure</span><span class="p">,</span><span class="w">   </span><span class="c1">// 配置和初始化函数 </span>
<span class="w">        </span><span class="p">.</span><span class="n">control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_control</span><span class="p">,</span><span class="w">	  </span><span class="c1">// 重新配置串口操作函数 常用的就是更改波特率</span>
<span class="w">        </span><span class="p">.</span><span class="n">putc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_putc</span><span class="p">,</span><span class="w">		      </span><span class="c1">// 串口发送一个字节</span>
<span class="w">        </span><span class="p">.</span><span class="n">getc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hc32_getc</span><span class="p">,</span><span class="w">			 </span><span class="c1">// 串口接收一个字节</span>
<span class="w">        </span><span class="p">.</span><span class="n">dma_transmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="w">       </span><span class="c1">// dma传输 这个一开始可以不实现</span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>首先，重点介绍两个比较重要的结构体</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_config</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 串口的名字</span>
<span class="w">    </span><span class="n">M0P_UART_TypeDef</span><span class="w"> </span><span class="o">*</span><span class="n">Instance</span><span class="p">;</span><span class="w">       </span><span class="c1">// 对应的串口硬件接口</span>
<span class="w">    </span><span class="n">IRQn_Type</span><span class="w"> </span><span class="n">irq_type</span><span class="p">;</span><span class="w">               </span><span class="c1">// 中断类型</span>

<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">stc_uart_cfg_t</span><span class="w"> </span><span class="n">stcCfg</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 和具体的MCU有关，配置结构体</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_config</span><span class="w"> </span><span class="o">*</span><span class="n">config</span><span class="p">;</span><span class="w">         </span><span class="c1">// 串口通用配置</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="n">serial</span><span class="p">;</span><span class="w">          </span><span class="c1">// 对接uart device 必要</span>

<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>接着实现config函数，这个函数的两个入参，一个是对接设备驱动框架的serial，通过serial我们能找到当前操作的是哪个串口，另一个就是配置cfg，这个cfg里的参数就是我们上面注册serial设备时的默认初始化参数 <em>RT_SERIAL_CONFIG_DEFAULT</em>。函数的具体实现逻辑我在函数体中做了注释。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">rt_err_t</span><span class="w"> </span><span class="nf">hc32_configure</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">struct</span><span class="w"> </span><span class="nc">serial_configure</span><span class="w"> </span><span class="o">*</span><span class="n">cfg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">serial</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">cfg</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_container_of</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="p">,</span><span class="w"> </span><span class="n">serial</span><span class="p">);</span><span class="w">   </span><span class="c1">// 通过serial来找到uart 然后操作这个uart</span>
<span class="w">    </span><span class="cm">/* 这里通过interface接口来确定具体操作哪个串口 实现方式和各个MCU有关系 可以参考MCU的SDK里给的simple */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">M0P_UART1</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">stc_gpio_cfg_t</span><span class="w"> </span><span class="n">stcGpioCfg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">DDL_ZERO_STRUCT</span><span class="p">(</span><span class="n">stcGpioCfg</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="cm">/* 使能时钟 */</span><span class="w"></span>
<span class="w">        </span><span class="n">Sysctrl_SetPeripheralGate</span><span class="p">(</span><span class="n">SysctrlPeripheralUart1</span><span class="p">,</span><span class="w"> </span><span class="n">TRUE</span><span class="p">);</span><span class="w"> </span><span class="c1">///&lt;使能uart1模块时钟</span>
<span class="w">        </span><span class="n">Sysctrl_SetPeripheralGate</span><span class="p">(</span><span class="n">SysctrlPeripheralGpio</span><span class="p">,</span><span class="w"> </span><span class="n">TRUE</span><span class="p">);</span><span class="w">  </span><span class="c1">//使能GPIO模块时钟</span>
<span class="w">		</span><span class="cm">/* 初始化IO */</span><span class="w"></span>
<span class="w">        </span><span class="c1">///&lt;TX</span>
<span class="w">        </span><span class="n">stcGpioCfg</span><span class="p">.</span><span class="n">enDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GpioDirOut</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Gpio_Init</span><span class="p">(</span><span class="n">GpioPortA</span><span class="p">,</span><span class="w"> </span><span class="n">GpioPin2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stcGpioCfg</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Gpio_SetAfMode</span><span class="p">(</span><span class="n">GpioPortA</span><span class="p">,</span><span class="w"> </span><span class="n">GpioPin2</span><span class="p">,</span><span class="w"> </span><span class="n">GpioAf1</span><span class="p">);</span><span class="w"> </span><span class="c1">//配置PA02 端口为URART1_TX</span>

<span class="w">        </span><span class="c1">///&lt;RX</span>
<span class="w">        </span><span class="n">stcGpioCfg</span><span class="p">.</span><span class="n">enDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GpioDirIn</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Gpio_Init</span><span class="p">(</span><span class="n">GpioPortA</span><span class="p">,</span><span class="w"> </span><span class="n">GpioPin3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stcGpioCfg</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Gpio_SetAfMode</span><span class="p">(</span><span class="n">GpioPortA</span><span class="p">,</span><span class="w"> </span><span class="n">GpioPin3</span><span class="p">,</span><span class="w"> </span><span class="n">GpioAf1</span><span class="p">);</span><span class="w"> </span><span class="c1">//配置PA03 端口为URART1_RX</span>
<span class="w">		</span><span class="cm">/* 具体的串口参数配置 各个MCU厂家各不相同 */</span><span class="w"></span>
<span class="w">        </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enRunMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMskMode3</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt;模式3</span>
<span class="w">        </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">stcBaud</span><span class="p">.</span><span class="n">u32Baud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">baud_rate</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">stcBaud</span><span class="p">.</span><span class="n">enClkDiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMsk8Or16Div</span><span class="p">;</span><span class="w">      </span><span class="c1">///&lt;通道采样分频配置</span>
<span class="w">        </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">stcBaud</span><span class="p">.</span><span class="n">u32Pclk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sysctrl_GetPClkFreq</span><span class="p">();</span><span class="w"> </span><span class="c1">///&lt;获得外设时钟（PCLK）频率值</span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">stop_bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">STOP_BITS_1</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enStopBit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMsk1bit</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">STOP_BITS_2</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enStopBit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMsk2bit</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enStopBit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMsk1_5bit</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">parity</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PARITY_NONE</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enMmdorCk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMskDataOrAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PARITY_ODD</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enMmdorCk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMskOdd</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">PARITY_EVEN</span><span class="p">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enMmdorCk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMskEven</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">            </span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">.</span><span class="n">enMmdorCk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UartMskDataOrAddr</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">Uart_Init</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">stcCfg</span><span class="p">));</span><span class="w"> </span><span class="c1">///&lt;串口初始化</span>

<span class="w">    </span><span class="c1">///&lt;UART中断使能</span>
<span class="w">    </span><span class="n">Uart_ClrStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="n">UartRC</span><span class="p">);</span><span class="w">                </span><span class="c1">///&lt;清接收请求</span>
<span class="w">    </span><span class="n">Uart_EnableIrq</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="n">UartRxIrq</span><span class="p">);</span><span class="w">             </span><span class="c1">///&lt;使能串口接收中断   </span>
<span class="w">    </span><span class="n">EnableNvic</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">irq_type</span><span class="p">,</span><span class="w"> </span><span class="n">IrqLevel3</span><span class="p">,</span><span class="w"> </span><span class="n">TRUE</span><span class="p">);</span><span class="w">       </span><span class="c1">///&lt;系统中断使能</span>


<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">RT_EOK</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>接下来实现的putc和getc就好办了，比较简单</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hc32_putc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">serial</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_container_of</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="p">,</span><span class="w"> </span><span class="n">serial</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Uart_SendDataPoll</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hc32_getc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">serial</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_container_of</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="p">,</span><span class="w"> </span><span class="n">serial</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Uart_GetStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="n">UartRC</span><span class="p">))</span><span class="w"> </span><span class="c1">//UART1数据接收</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Uart_ClrStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="n">UartRC</span><span class="p">);</span><span class="w">     </span><span class="c1">// 清中断状态位</span>
<span class="w">        </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Uart_ReceiveData</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">);</span><span class="w">      </span><span class="c1">// 接收数据字节</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>最后，我们再分析一下，串口的中断接收。</p>
<p>根据MCU的SDK里的串口中断接收simple，首先找到中断服务函数放在drv_uart.c里，如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(BSP_USING_UART1) || defined(BSP_USING_UART3)</span>
<span class="c1">//UART1中断函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UART1_3_IRQHandler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* enter interrupt */</span><span class="w"></span>
<span class="w">    </span><span class="n">rt_interrupt_enter</span><span class="p">();</span><span class="w"></span>
<span class="cp">#if (INT_CALLBACK_ON == INT_CALLBACK_UART1)  </span>
<span class="w">    </span><span class="n">uart_isr</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">uart_obj</span><span class="p">[</span><span class="n">UART1_INDEX</span><span class="p">].</span><span class="n">serial</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="cm">/* leave interrupt */</span><span class="w"></span>
<span class="w">    </span><span class="n">rt_interrupt_leave</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>然后在中断服务函数里调用uart_isr函数，这个函数也是我们需要实现的函数，如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Uart common interrupt process. This need add to uart ISR.</span>
<span class="cm"> *</span>
<span class="cm"> * @param serial serial device</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">uart_isr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rt_serial_device</span><span class="w"> </span><span class="o">*</span><span class="n">serial</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">RT_ASSERT</span><span class="p">(</span><span class="n">serial</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">RT_NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt_container_of</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hc32_uart_t</span><span class="p">,</span><span class="w"> </span><span class="n">serial</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* UART in mode Receiver -------------------------------------------------*/</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">Uart_GetStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">UartRC</span><span class="p">))</span><span class="w">         </span><span class="c1">//UART1数据接收</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">rt_hw_serial_isr</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span><span class="w"> </span><span class="n">RT_SERIAL_EVENT_RX_IND</span><span class="p">);</span><span class="w">      </span><span class="c1">// 在getc里清除中断</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">Uart_GetStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="n">UartTC</span><span class="p">))</span><span class="w">         </span><span class="c1">//UART1数据发送</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Uart_ClrStatus</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">Instance</span><span class="p">,</span><span class="w"> </span><span class="n">UartTC</span><span class="p">);</span><span class="w">        </span><span class="c1">//清中断状态位</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在这个函数里，我们要分析当前发生的是什么中断，并处理对应的中断，常见的中断有接收中断、发送中断以及DMA中断等等。这里，我们只处理接收中断，在接收中断中，调用<code class="docutils literal notranslate"><span class="pre">rt_hw_serial_isr</span></code>函数来通知serial框架有中断发生，并告知中断类型，然后<code class="docutils literal notranslate"><span class="pre">rt_hw_serial_isr</span></code>会调用我们驱动中实现的getc函数来接收一个字符，在getc中要注意，<strong>接收完成一个字符后，要清除中断标志位。</strong></p>
<p>这些操作都完成后，串口驱动应该就能跑起来了。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> \ | /
- RT -     Thread Operating System
 / | \     4.0.3 build May 19 2021
 2006 - 2021 Copyright by rt-thread team
Os is Start!!! 
msh &gt;
msh &gt;
msh &gt;
msh &gt;
</pre></div>
</div>
<p>当然，如有要更改串口波特率或者校验位 数据位等串口配置参数，就要实现control函数了。这里就不过多介绍了。</p>
</section>
</section>
<section id="id5">
<h2><span class="section-number">12.3. </span>问题&amp;总结<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h2>
<ul class="simple">
<li><p>串口驱动实现的重点是要挂接串口驱动函数到serial设备框架，然后再实现每个函数</p></li>
<li><p>我们在做串口驱动的时候，应该先熟悉目标开发板的SDK里面的串口相关驱动函数，然后在此基础上再做移植</p></li>
<li><p>遇到问题应该单步调试一下，主要是看 <code class="docutils literal notranslate"><span class="pre">uart</span> <span class="pre">=</span> <span class="pre">rt_container_of(serial,</span> <span class="pre">struct</span> <span class="pre">hc32_uart_t,</span> <span class="pre">serial);</span></code> 这里有没有获取到正确的uart</p></li>
<li><p>对于同系列的MCU要考虑兼容性，但是先实现的时候以实现目标为准，然后再考虑重构和优化</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="03_rtthread_bsp_porting_spi.html" class="btn btn-neutral float-left" title="11. RTTHREAD移植BSP驱动 SPI篇" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../04_docker/01_docker_images.html" class="btn btn-neutral float-right" title="13. 如何用docker来学习rtthread-qemu" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2020, apache.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>